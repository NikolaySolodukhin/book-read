Одной из главной концепции в JS, является ООП которое напрямую связанно с prototype и ключевым словом `this`.

this - это привязка которая создается во время вызова функции и на то, что она ссылается определяется тем, где и при каких условиях функция была вызвана.



`Неявная привязка`. 

Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект стоит использовать для привязки this к вызову функции.

Только верхний/последний уровень ссылки на свойство объекта в цепочке имеет значение для точки вызова.

`Потеря неявной привязки`
Часто бывает, что неявно привязанная функция теряет эту привязку, что обычно означает что она вернется к привязке по умолчанию, либо объекту global или undefined в зависимости от режима `strict mode`.


`Явная привязка.`

У всех функций есть есть несколько инструментов доступных черех из прототип. Это методы функций call и apply для привязки контекста. Однако эти методы не дают явной гарантии, что контекст функции не будет потерян. 


`Жесткая привязка`

Для жесткой привязки у функции в ее прототипе есть метод `bind`. Он возвращает новую функцию в которой жестко задан вызов оригинальной функции именно с тем контекстом с которым вы указываете. 


Полифилл для `bind`:

```javascript
function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments);
    }
  }
}
```


`Привязка new`

В JS - конструкторы всего лишь функции.

Когда функция вызывается с указаением перед ней `new`, также известный как вызов конструктора, автоматически выполняются следующие вещи:

1) Создается новый объект из воздуха

2) Только что сконструированный объект связывается с прототипом

3) Только что сконструированный обхект устанавливается как привязка this для этого вызова функции

4) За исключением тех случаев, когда функция возвращает свой собственной алтернативный объект, вызов функции с new автоматически вернет только, что сконструированный объект.

Таким образом, `new` - единственный путь, которым `this` при вызове функции может быть привязан.


`Приоритеты привязки.`

Явная привязка имеет выше приоритет, чем неявная привязка.

Привязка `new` более приоритетна, чем неявная привязка. 

При создании с оператором new происходит перекрытие жесткой привязкой сделанной при помощи `bind`.



Отметим, чем `this` не является.

1) `this` - это не ссылка на функции на саму себя и это не ссылка на `область видимости` функции.


Определим `this`.

1) Функция вызвана с `new`. Раз так, то `this` - новый сконструированный объект.

```javascript
var bar = new foo()
```

2) Функция вызвана с `call` или `apply` или даже с `bind` то `this` - явно указанный объект.

```javascript
var bar = foo.call( obj2 )
```

3) Функция вызвана с контекстом (неявная привязка), иначе называемым как владеющий или содержащий объект. `this`- является тем самым объектом контекста.

4) В противном случае this ведет себя по умолчанию и является глобальным объектом `window` в режиме `strict mode` или же `undefined`;


`Игнорирование this`. 

Если мы передадим `null` или `undefined` в методы `call`, `apply` или `bind` то значения проигнорируются и взамен будет использоваться привязка по умолчанию.

Казалось, бы это является хорошей идей, например для распаковки массива 

```javascript
function foo(a,b) {
  console.log ("a": + a + ", b:" +b );
}

foo.apply (null, [2, 3]).

```

Но с другой стороны у нас есть оператор rest/spread из ECMAScript 6. Однако, лучше не пользоваться таким способом при использовании стороней библиотеки, так как может в худшем случае произоити мутация на глобальном объекте window.

Ах, да забыл отметить, для того, что избежать потери(подмены) this в обработчиках событий нужно/можно использовать стрелочные функции, у них нет контекста выполнения.

Кстати, для прототипного наследования методов в избежании проблем с this. Хорошей практикой является использовать Object.create(Cat.prototype). Копируем все методы объекта Cat лежащие в его прототипе.


Объекты:

В JS 7 типов:

1) string

2) number

3) boolean

4) null

5) undefined

6) object

7) symbol

 Подтипы объектов(встроенные объекты):

 1) String
 2) Number
 3) Boolean
 4) Object
 5) Function
 6) Array
 7) Date
 8) RegExp
 9) Error

 Большая часть сообщества JS разработчиков настоятельно рекомендуют использовать литеральную форму записи. Использовать конструкторную форму только если нужны дополнительные опции.

 `Дескрипторы свойств`

 В ES5 с помощью конструкции Object.getOwnPropertyDesciptor(имя объекта, его свойство).
 Мы можем узнать writable,enurable и configurable.

 Особенность есть configurable задано как false то writable можно изменить на false, но не обратно. 

 Забавный момент. У некоторых разработчиков вызывает негодование запись

```javascript 
 const a.foo = 1;

 a.foo = 2;
```

 Значение свойства перезапишется! И да тут все ок. Чтобы сделать действительно константу необходимо определить свойство с помощью getDefineProperty с configurable:false, writable:false.

`Запечатывание.`

Метод `Object.seal()` - создает запечатанный объект - то есть принимает существующий объект и применяет `Object.preventExtensions()`, но также помечает все существующие свойства как configurable:false. 

 Стоит отметить метод `Object.freeze()` - который замораживает объект. Применяет `Object.seal()` а также помечается все свойства как writable:false. Такой способ, наивысший уровень иммутабельности.

 `Геттеры` - это свойства которые на самом деле вызывает скрытую функцию для получения значения.

 `Сеттеры` - это свойства которые на самом деле вызывает скрытую функцию для задания значения. 

`Великий Прототип.`

`Конструктор` - это любая функция, вызванная с ключевым словом `new` перед ней.
Функции не являются конструкторами, но вызовы функций являются "вызовами конструктора" тогда и только тогда когда используется `new`.

`Прототипное наследование` 

Пример: 
```javascript
function Foo(name) {
  this.name = name;
}


Foo.prototype.myName = function() {
  return this.name;
}

function Bar(name, label) {
  Foo.call(this, name);
  this.label = label
}

Делаем прототипной наследование

Bar.prototype = Object.create(Foo.prototype);

`Bar.prototype.constructor отсуствует`
Прописываем заново

Bar.prototype.myLabel = function() {
  return this.label;
}

var a = new Bar( "a", "obj a")

a.myName(); //"a"
a.myLabel(); //"obj a"
```
`Object.create` - создает  новый объект из ничего и связывает внутренную ссылку [[Prototype]] этого объекта с указанным объектом в нашем случае (Foo.prototype).

При объявлении function Bar {...} функция Bar получает ссылку [[Prototype]] на объект по умолчанию. Но этот объект не ссылается на Foo.prototype как мы хотим, поэтому мы создаем новый объект который имеет нужную ссылку.

`Typical Error`

```javascript

Bar.prototype = Foo.prototype;

или

Bar.prototype = new Foo();
```

Bar.prototype = Foo.prototype не создает новый объект на который бы ссылалось бы Bar.prototype.
Вместо этого Bar.prototype становиться еще одной ссылкой на Foo.prototype. Таким образом Bar.prototype связывается напрямую с тем же объектом, что и Foo.prototype. Тем, самым когда мы начнем присваивать значени Bar.prototype.ololo = , мы изменим не отдельны объект а общий объект Foo.prototype, что повлияет на любые объекты привязанные к Foo.prototype. 

При вызове конструктора все работает так как надо, но могут возникнуть побочные эффекты. Например если эта функции Foo имеет (логирование, добавление свойств в this, регистрации в других объектах) то во время привязывания, они сработают.

Единственный правильный способ через Object.create. Но у него есть недостаток. Приходитс создать новый объект, выбрасывая старый, вместо того, чтобы модифицировать существующий стандартный объект. И этот способ `есть`.

ES6

```javascript

Object.setPrototypeOf(Bar.prototype, Foo.prototype);
```