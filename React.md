Проблему медленного DOM можно решать несколькими принципиальными способами:

1) Виртуальный DOM — путь React.js и других подобных библиотек.
2) Стандарты веб-компонентов, которые сейчас в разработке (Shadow DOM)

Имея DOM, c кусочками html можно делать что угодно, но каждое изменение стилей или разметки вызывает repaint и, возможно, reflow, что ведет к снижению производительности. Это особенно заметно при работе с большим количеством html элементов.

Виртуальный DOM — это дерево javascript объектов, повторяющее структуру реального DOM-дерева, но более легковесное (в чем его легкость, интересно? Что они выкинули?). И работать с ним быстрее. Изменения виртуального DOM группируются и применяются к реальному DOM реже, что также способствует повышению производительности.


Алгоритм React использует для сравнения одно дерево с другим, чтобы определить, какие части необходимо изменить.

Виртуальная DOM (VDOM) - это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса сохраняется в памяти и синхронизируется с «реальной» DOM библиотекой, такой как ReactDOM. Этот процесс называется сверкой (reconciliation)

Is the Shadow DOM the same as the Virtual DOM?

Нет, они разные. Shadow DOM - это технология браузера, разработанная в первую очередь для переменных охвата и CSS в веб-компонентах. Виртуальная DOM - это концепция, реализованная библиотеками в JavaScript поверх API-интерфейсов браузера.


Поскольку «виртуальный DOM» является скорее паттерном, чем конкретной технологией, люди иногда говорят, что это разные вещи. В мире React термин «виртуальный DOM» обычно ассоциируется с элементами React, поскольку они представляют собой объекты, представляющие пользовательский интерфейс. Однако для этого требуется также использование внутренних объектов, называемых «волокнами», для хранения дополнительной информации о дереве компонентов. Они также могут считаться частью реализации «виртуальной DOM» в React.



Жизненный цикл React компонента?
Создание и инициализация компонента (constructor)

Если вы не инициализируете состояние и не связываете методы, вам не нужно реализовывать конструктор для вашего компонента React.

Конструктор для компонента React вызывается до его установки. При реализации конструктора подкласса React.Component вы должны вызвать super (реквизиты) перед любым другим оператором. В противном случае this.props не будет определен в конструкторе, что может привести к ошибкам.

Как правило, в конструкциях React используются только для двух целей:

Инициализация локального состояния путем назначения объекта this.state.
Привязка методов обработчика события к экземпляру.


1) static getDerivedStateFromProps(props, state)

getDerivedStateFromProps вызывается непосредственно перед вызовом метода рендеринга, как на начальном монтировании, так и на последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. 

Этот метод существует для случаев редкого использования, когда состояние зависит от изменений в реквизитах с течением времени. Например, может быть удобно реализовать компонент <Transition>, который сравнивает своих предыдущих и следующих детей, чтобы решить, из какого из них можно анимировать и выходить.
Обратите внимание, что этот метод запускается на каждом рендере независимо от причины.

2) Затем срабатывает метод отрисовки компонента render()
Функция render () должна быть чистой, что означает, что она не изменяет состояние компонента, она возвращает один и тот же результат при каждом вызове и не взаимодействует напрямую с браузером.

Если вам нужно взаимодействовать с браузером, выполните свою работу в componentDidMount () или других методах жизненного цикла. Удержание render () pure делает компоненты более легкими для размышлений.



3) Срабатывает метод componentDidMount();

componentDidMount () вызывается сразу после установки компонента (вставленного в дерево). Инициализация, требующая узлов DOM, должна идти здесь. Если вам нужно загружать данные с удаленной конечной точки, это хорошее место для создания экземпляра сетевого запроса.

Этот метод является хорошим местом для настройки подписки. Если вы это сделаете, не забудьте отказаться от подписки в компонентеWillUnmount ().

Вы можете сразу же вызвать setState () в componentDidMount (). Это вызовет дополнительный рендеринг, но это произойдет до того, как браузер обновит экран. Это гарантирует, что даже если render () будет вызываться дважды в этом случае, пользователь не увидит промежуточное состояние. Используйте этот шаблон с осторожностью, поскольку он часто вызывает проблемы с производительностью. В большинстве случаев вы должны иметь возможность назначить начальное состояние в конструкторе (). Однако это может быть необходимо для таких случаев, как модалы и всплывающие подсказки, когда вам нужно измерить узел DOM, прежде чем отображать что-то, зависящее от его размера или положения.
Здесь компонент живет сколько ему надо, обновляется и перерисовывается (см ниже);
Перед удалением компонента из DOM срабатывает componentWillUnmount();



Каждое обновление компонента протекает так:

Вызывается метод 
static getDerivedStateFromProps(props, state)


shouldComponentUpdate(nextProps, nextState)
Этот метод существует только как оптимизация производительности. Не полагайтесь на это, чтобы «предотвратить» рендеринг, так как это может привести к ошибкам. Подумайте о том, как использовать встроенный PureComponent вместо того, чтобы вручную записывать файл mustComponentUpdate (). PureComponent выполняет мелкое сравнение реквизита и состояния и уменьшает вероятность того, что вы пропустите необходимое обновление.

Если вы уверены, что хотите написать его вручную, вы можете сравнить this.props с nextProps и this.state с nextState и вернуть false, чтобы сказать React update можно пропустить. Обратите внимание, что возвращение false не предотвращает повторное рендеринг дочерних компонентов при изменении их состояния.

Мы не рекомендуем делать глубокие проверки равенства или использовать JSON.stringify () в shouldComponentUpdate (). Это очень неэффективно и будет наносить ущерб производительности.

В настоящее время, если shouldComponentUpdate () возвращает false, то UNSAFE_componentWillUpdate (), render () и componentDidUpdate () не будут вызываться. В будущем React может рассматривать shouldComponentUpdate () как подсказку, а не строгую директиву, а возврат false может по-прежнему приводить к повторному рендерингу компонента.


для вычисления необходимости отрисовки.
Собственно обновление render()

getSnapshotBeforeUpdate()


И наконец componentDidUpdate(prevProps, prevState, snapshot);

вызывается сразу после обновления. Этот метод не вызывается для первоначального рендеринга.

Используйте это как возможность работать с DOM при обновлении компонента. Это также хорошее место для выполнения сетевых запросов, если вы сравниваете текущие реквизиты с предыдущими реквизитами (например, сетевой запрос может не понадобиться, если реквизит не изменился).

```javascript
componentDidUpdate(prevProps) {
  // Typical usage (don't forget to compare props):
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```


component.forceUpdate(callback)

По умолчанию, когда состояние вашего компонента или реквизита изменяется, ваш компонент будет повторно отображать. Если метод render () зависит от некоторых других данных, вы можете сказать React, что компонент нуждается в повторном рендеринге, вызвав forceUpdate ().

Вызов forceUpdate () вызовет функцию render () для компонента, пропуская shouldComponentUpdate (). Это вызовет обычные методы жизненного цикла для дочерних компонентов, включая метод shouldComponentUpdate () для каждого дочернего элемента. React по-прежнему будет обновлять DOM только в случае изменения разметки.

Обычно вы должны стараться избегать всех применений forceUpdate () и читать только из этого.props и this.state в render () ..



setState(updater[, callback])

setState () устанавливает изменения в состоянии компонента и сообщает React, что этот компонент и его дочерние элементы должны быть повторно отображены с обновленным состоянием. Это основной метод, который вы используете для обновления пользовательского интерфейса в ответ на обработчики событий и ответы сервера.

Подумайте о SetState () как о запросе, а не о немедленной команде для обновления компонента. Для лучшей воспринимаемой производительности React может задержать ее, а затем обновить несколько компонентов за один проход. Реакция не гарантирует немедленного применения изменений состояния.

setState () не всегда сразу обновляет компонент. Он может перезагружать или откладывать обновление до следующего. Это делает чтение this.state прямо после вызова setState () потенциальной ловушки. Вместо этого используйте componentDidUpdate или обратный вызов setState (setState (updater, callback)), любой из которых гарантированно срабатывает после того, как обновление было применено. Если вам нужно установить состояние, основанное на предыдущем состоянии, ознакомьтесь с приведенным ниже аргументом updater.

setState () всегда приведет к повторной обработке, если shouldComponentUpdate () возвращает false. Если используются изменяемые объекты и логика условного воспроизведения не может быть реализована в shouldComponentUpdate (), вызов setState () только тогда, когда новое состояние отличается от предыдущего состояния, избежит ненужных повторных рендерингов.

this.setState((prevState, props) => {
  return {counter: prevState.counter + props.step};
});

Второй параметр для setState () - это необязательная функция обратного вызова, которая будет выполняться после завершения setState и повторной визуализации компонента. Обычно мы рекомендуем использовать для этой логики componentDidUpdate ().



ReactDOM.render(element, container[, callback])



React.PureComponent
Если функция render () компонента React отображает тот же результат при одинаковых реквизитах и состоянии, вы можете использовать React.PureComponent для повышения производительности в некоторых случаях.

React.PureComponent shouldComponentUpdate () только мелко сравнивает объекты. Если они содержат сложные структуры данных, это может привести к ложным отрицаниям для более глубоких различий. Расширяйте PureComponent только в том случае, если вы ожидаете иметь простые реквизиты и состояние, или используйте forceUpdate (), когда вы знаете, что глубокие структуры данных изменились. Или рассмотрите возможность использования неизменяемых объектов для быстрого сравнения вложенных данных.

Кроме того, команда React.PureComponent shouldComponentUpdate () пропускает обновления для всего поддерева компонента. Убедитесь, что все компоненты для детей также «чисты».


React.createElement(
  type,
  [props],
  [...children]
)



В чем разница между createElement и cloneElement?
createElement мы получаем из JSX и его React использует для создания элементов (объектное представление некоторого интерфейса). cloneElement используется для клонирования элемента и отправить ему новые параметры.

React.cloneElement(
  element,
  [props],
  [...children]
)


const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// You can now get a ref directly to the DOM button:
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;



Цель React Fiber - увеличить его пригодность для таких областей, как анимация, макет и жесты. Его функция заголовка - инкрементный рендеринг: возможность разделить рендеринг на куски и разложить его на несколько кадров.

Другие ключевые функции включают возможность приостановки, прерывания или повторного использования работы при появлении новых обновлений; возможность назначать приоритет различным типам обновлений; и новые примитивы параллелизма.



What does setState do?

setState() schedules an update to a component’s state object. When state changes, the component responds by re-rendering.


What is the difference between state and props?

пропсы (сокращение от «свойств») и состояние - это обычные объекты JavaScript. Хотя оба содержат информацию, которая влияет на рендер, они различаются одним важным способом: пропсы передаются компоненту (аналогично параметрам функции), тогда как состояние управляется внутри компонента (подобно переменным, объявленным внутри функции).


Why is setState giving me the wrong value?

В React оба this.props и this.state представляют отображаемые значения, то есть то, что в данный момент отображается на экране.

Вызовы в SetState асинхронны - не полагайтесь на this.state, чтобы отражать новое значение сразу после вызова setState. Передайте функцию обновления вместо объекта, если вам нужны значения вычислений на основе текущего состояния (подробнее см. Ниже).

Пример кода, который не будет вести себя так, как ожидалось:

```javascript
incrementCount() {
  // Note: this will *not* work as intended.
  this.setState({count: this.state.count + 1});
}

handleSomething() {
  // Let's say `this.state.count` starts at 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();
  // When React re-renders the component, `this.state.count` will be 1, but you expected 3.

  // This is because `incrementCount()` function above reads from `this.state.count`,
  // but React doesn't update `this.state.count` until the component is re-rendered.
  // So `incrementCount()` ends up reading `this.state.count` as 0 every time, and sets it to 1.

  // The fix is described below!
}
```

```javascript
incrementCount() {
  this.setState((prevState) => {
    // Important: read `prevState` instead of `this.state` when updating.
    return {count: prevState.count + 1}
  });
}

handleSomething() {
  // Let's say `this.state.count` starts at 0.
  this.incrementCount();
  this.incrementCount();
  this.incrementCount();

  // If you read `this.state.count` now, it would still be 0.
  // But when React re-renders the component, it will be 3.
}
```

When is setState asynchronous?
Currently, setState is asynchronous inside event handlers.


Почему не React update this.state синхронно?
Как объяснялось в предыдущем разделе, React намеренно «ждет» до тех пор, пока все компоненты не вызовут setState () в своих обработчиках событий, прежде чем приступать к повторной обработке. Это повышает производительность, избегая ненужных повторных передач.

Тем не менее, вы все равно можете задаться вопросом, почему React не просто обновляет this.state немедленно без повторной рендеринга.

Есть две основные причины:

Это нарушит согласованность между пропсами и состоянием, вызывая проблемы, которые очень трудно отлаживать.

Это сделало бы некоторые из новых функций, над которыми мы работаем, которые невозможно реализовать.


Where in the component lifecycle should I make an AJAX call?
You should populate data with AJAX calls in the componentDidMount lifecycle method. This is so you can use setState to update your component when the data is retrieved.




React поддерживает специальный атрибут, который можно присоединить к любому компоненту. Атрибут ref может быть объектом, созданным функцией React.createRef () или функцией обратного вызова, или строкой (в устаревшем API). Когда атрибут ref является функцией обратного вызова, функция получает в качестве аргумента базовый элемент DOM или экземпляр класса (в зависимости от типа элемента). Это позволяет вам иметь прямой доступ к элементу DOM или экземпляру компонента.

Используйте refs экономно. Если вы часто используете ссылки, чтобы «сделать все возможное» в вашем приложении, подумайте о том, чтобы лучше ознакомиться с потоком данных сверху вниз.

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);

    this.inputRef = React.createRef();
  }

  render() {
    return <input type="text" ref={this.inputRef} />;
  }

  componentDidMount() {
    this.inputRef.current.focus();
  }
}
```



Ключи
«Ключ» - это специальный атрибут строки, который необходимо включить при создании массивов элементов. Справка по ключам. Реагируйте, какие элементы были изменены, добавлены или удалены. Ключи должны быть предоставлены элементам внутри массива, чтобы дать элементам устойчивое тождество.

Ключи должны быть уникальными только среди элементов-близнецов в одном массиве. Они не обязательно должны быть уникальными во всем приложении или даже в одном компоненте.

Не пропускайте что-то вроде Math.random () для ключей. Важно, чтобы ключи имели «стабильную идентичность» для повторного рендеринга, чтобы React мог определять, когда элементы добавляются, удаляются или переупорядочиваются. В идеале, ключи должны соответствовать уникальным и стабильным идентификаторам, поступающим из ваших данных, таких как post.id.



Реакт имеет два разных подхода к работе с входными формами.

Элемент входной формы, значение которого контролируется React, называется управляемым компонентом. Когда пользователь вводит данные в управляемый компонент, запускается обработчик события изменения, и ваш код решает, является ли вход действительным (путем повторного рендеринга с обновленным значением). Если вы не будете повторно отображать, элемент формы останется без изменений.

Неконтролируемый компонент работает, как элементы формы, вне React. Когда пользователь вводит данные в поле формы (поле ввода, раскрывающийся список и т. Д.), Обновленная информация отражается без необходимости реагирования. Однако это также означает, что вы не можете заставить поле иметь определенное значение.

В большинстве случаев вы должны использовать контролируемые компоненты.


Методы жизненного цикла
Методы жизненного цикла - это настраиваемые функции, которые выполняются на разных этапах компонента. Существуют методы, доступные при создании и вставке компонента в DOM (установка), когда компонент обновляется, а также когда компонент размонтируется или удаляется из DOM.


State 

Компонент нуждается в состоянии, когда некоторые данные, связанные с ним, со временем меняются. Например, компоненту Checkbox может потребоваться isChecked в его состоянии, и компонент NewsFeed может захотеть отслеживать fetchedPosts в своем состоянии.

Самое важное различие между состоянием и реквизитом заключается в том, что пропс передается из родительского компонента, но состояние управляется самим компонентом. Компонент не может изменить свой реквизит, но он может изменить свое состояние. Для этого он должен вызвать this.setState (). Только компоненты, определенные как классы, могут иметь состояние.

Для каждой конкретной части изменяющихся данных должен быть только один компонент, который «владеет» им в своем состоянии. Не пытайтесь синхронизировать состояния двух разных компонентов. Вместо этого поднимите его до ближайшего общего предка и передайте его в качестве опоры для обоих.


Elements
React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of “components”. An element describes what you want to see on the screen. React elements are immutable.


JSX - это расширение синтаксиса для JavaScript. Он похож на язык шаблонов, но он обладает всеми возможностями JavaScript. JSX скомпилируется для вызовов React.createElement (), которые возвращают объекты JavaScript, называемые «React elements». Чтобы получить базовое введение в JSX, ознакомьтесь с документами здесь и найдите здесь более подробное руководство по JSX.




Context API.
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    // Use a Provider to pass the current theme to the tree below.
    // Any component can read it, no matter how deep it is.
    // In this example, we're passing "dark" as the current value.
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// A component in the middle doesn't have to
// pass the theme down explicitly anymore.
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton(props) {
  // Use a Consumer to read the current theme context.
  // React will find the closest theme Provider above and use its value.
  // In this example, the current theme is "dark".
  return (
    <ThemeContext.Consumer>
      {theme => <Button {...props} theme={theme} />}
    </ThemeContext.Consumer>
  );
}